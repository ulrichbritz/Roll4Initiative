using System;
using UnityEditor;
using UnityEngine;
using UnityEditor.SceneManagement;
using System.Collections.Generic;
using System.Linq;

namespace InnerDriveStudios.DiceCreator
{
    /**
     * The DieSidesEditor provides the editor for the DieSides component, which allows you to fill
     * the DieSides component with all the required DieSides instances based on data provided by the
     * DieAreaFinder class. This allows you to construct your own die with custom side data for each side, 
     * with handy features such as viewing the side normals, rotating the transform to match a certain
     * value, and highlighting a specific DieSide.
     * 
     * @author J.C. Wichman
     * @copyright Inner Drive Studios 2018
     */
    [CustomEditor(typeof(DieSides))]
    [CanEditMultipleObjects]
    public class DieSidesEditor : Editor
    {
        //References to static variables for layouting:

        private static GUIContent _rotateButtonContent = new GUIContent("R", "Highlights this side and rotates the transform to match it.");

        private static GUILayoutOption[] _smallEditorButtonOptions = { GUILayout.Width(20) };
        private static GUILayoutOption[] _sideLabelOptions = { GUILayout.Width(50.0f) };
        private static GUILayoutOption[] _dataCountLabelOptions = { GUILayout.MaxWidth(130.0f), GUILayout.ExpandWidth(false) };
        private static GUILayoutOption[] _fillerLabelOptions = { GUILayout.MaxWidth(0), GUILayout.ExpandWidth(true) };
        private static GUILayoutOption[] _dataValueOptions = { GUILayout.ExpandWidth(true), GUILayout.MinWidth(10.0f) };

        private static Color darkGreen = new Color(0, 0.5f, 0);
        private static Color darkBlue = new Color(0, 0, 0.8f);

        //some more layouting variables, but these have to be initialized before use:

        private static bool _initialized = false;
        private static GUIStyle _boldFoldout;
        private static GUIStyle _centeredText;
        private static GUIStyle _centeredBox;
        private static GUIStyle _sideLabelStyle;

        //all areas whose area size is less than areaCutOffMultiplier*maxAreaSize are removed
        //during the side finding process, where maxAreaSize is calculated during that process
        private static float _areaCutOffMultiplier = 0.95f;

        //how long should the drawn debug normals be and consequently 
        //at which distance should the debug labels be drawn
        private static float _labelDrawDistance = 1;
        //what should be the color of the labels
        private static Color _labelDrawColor = Color.black;
		private static bool _debugViewOn = true;

        //should we display the data for all sides so you can edit it?
        private static bool _sideDataDisplayed = true;

        //storage for all the debug data generated by the DieSideFinder class
        private string _generationDebugData = "";
        private bool _showGenerationDebugData = false;

        //variable to keep track of whether a side is highlighted and if yes, which one
        private int _highlightedIndex = -1;

        //References to serialized properties from the DieSides class, so that we can edit them:

        //the sides array of the DieSides instance we would like to fill with all the deduced side data
        private SerializedProperty _dieSides;
        //what match type are we using (are we matching an upwards or downwards normal, depends on Die type)
        private SerializedProperty _matchType;
        //how many data values does each die side have?
        private SerializedProperty _valueCountPerSide;
        
        //names of the property fields in the DieSides component
        private const string _dieSidesPropertyName = "_dieSides";
        private const string _matchTypePropertyName = "_matchType";
        private const string _valueCountPerSidePropertyName = "_valueCountPerSide";
        //name of the required property field in the DieSide instance
        private const string _dieSideValuesPropertyName = "values";

        
        private void OnEnable()
        {
            //see the DieSides script, all these properties match with variables from that script
            _dieSides = serializedObject.FindProperty(_dieSidesPropertyName);
            _matchType = serializedObject.FindProperty(_matchTypePropertyName);
            _valueCountPerSide = serializedObject.FindProperty(_valueCountPerSidePropertyName);
            _highlightedIndex = -1;
        }

        public override void OnInspectorGUI()
        {
            ensureStyles();

            DiceCreatorLogoRenderer.ShowLogo();
			onInspectorGUIAlways();

            if (serializedObject.isEditingMultipleObjects)
            {
                onInspectorGUIMultiple();
            } else
            {
                onInspectorGUISingle();
            }

        }

        private void onInspectorGUISingle()
        {
			bool debugPrev = _debugViewOn;
			serializedObject.Update();

            bool hasSides = _dieSides.arraySize > 0;

            EditorGUILayout.Space();
            showDieTypeLabel();

            if (hasSides)
            {
                //if the generation process ran and completed during this editors current activation
                if (_showGenerationDebugData)
                {
                    EditorGUILayout.HelpBox(
                        _dieSides.arraySize + " sides were found, if this is correct " +
                        "you can start entering data for all the sides, " +
                        "if this was not correct, check the generator info below and try clearing/recalculating " +
                        "the sides with a different cut-off value or a simpler stand-in mesh.",
                        MessageType.Info
                    );
                }

                EditorGUILayout.Space();
                EditorGUILayout.PropertyField(_matchType);
                EditorGUILayout.Space();
                showDataSidesManipulationUI();
                EditorGUILayout.Space();

                EditorGUILayout.LabelField("Debug scene visualization:", EditorStyles.boldLabel);
				_debugViewOn = EditorGUILayout.ToggleLeft("Show debug info:", _debugViewOn);
                _labelDrawDistance = EditorGUILayout.Slider("Label distance:", _labelDrawDistance, 0, 2);
                _labelDrawColor = EditorGUILayout.ColorField("Label color:", _labelDrawColor);
            }
            else
            {
                showCalculateSidesUI();
            }

            if (_generationDebugData.Length > 0)
            {
                EditorGUILayout.Space();
                _showGenerationDebugData = EditorGUILayout.Foldout(_showGenerationDebugData, "Generator info", _boldFoldout);
                if (_showGenerationDebugData) EditorGUILayout.HelpBox(_generationDebugData, MessageType.Info);
            }

            serializedObject.ApplyModifiedProperties();

			if (debugPrev != _debugViewOn) SceneView.RepaintAll();
        }

        private void showDieTypeLabel()
        {
            if (_dieSides.arraySize == 0)
            {
                EditorGUILayout.LabelField(new GUIContent("Die type: <unknown>", "Press 'Calculate sides' to deduct the Die type."), EditorStyles.boldLabel);
            }
            else
            {
                EditorGUILayout.LabelField("Die type: D" + _dieSides.arraySize, EditorStyles.boldLabel);
            }
        }

        /**
         * Show the UI that allows you to trigger the side finding algorithm.
         */
        private void showCalculateSidesUI()
        {
            EditorGUILayout.HelpBox(
                "There is no side info available for this object, "+
                "press the 'Calculate sides' to fix this.", 
                MessageType.Info
            );

            _areaCutOffMultiplier = EditorGUILayout.Slider(
                new GUIContent(
                    "Cut off value:",
                    "All areas with a size that falls below " + (_areaCutOffMultiplier * 100) + "% of the maximum area size will be ignored."
                ),
                _areaCutOffMultiplier,
                0,
                1
            );

            if (GUILayout.Button("Calculate sides"))
            {
                //find all die sides through our findDieSides algorithm
                DieSides dieSides = target as DieSides;
                Mesh mesh = null;

                //if we have a collider, use the collider for the normals, otherwise our regular mesh
                MeshCollider meshCollider = dieSides.GetComponent<MeshCollider>();
                if (meshCollider != null)
                {
                    mesh = meshCollider.sharedMesh;
                } else
                {
                    MeshFilter meshFilter = dieSides.GetComponent<MeshFilter>();
                    mesh = meshFilter.sharedMesh;
                }

                List<DieAreaFinder.DieArea> foundSides = DieAreaFinder.FindDieAreas(mesh, _areaCutOffMultiplier);
				//show any debug data that was generated during this process
                _generationDebugData = DieAreaFinder.LogContents();
				_showGenerationDebugData = true;

				if (foundSides.Count == 0) return;

				_matchType.enumValueIndex = (foundSides.Count == 4) ? 1 : 0;

				//initialize our serialized properties with values based on the found die sides
				_dieSides.arraySize = foundSides.Count;

                for (int i = 0; i < foundSides.Count; i++)
                {
                    DieAreaFinder.DieArea foundSide = foundSides[i];
                    SerializedProperty dieSide = _dieSides.GetArrayElementAtIndex(i);
                    dieSide.FindPropertyRelative("_normal").vector3Value = foundSide.normal;
                    dieSide.FindPropertyRelative("_centerPoint").vector3Value = foundSide.centerPoint;
                }
                
				//make sure all data values are initialized for each dieside
                ensureDataValueCountPerSide();

				//save properties then align
				serializedObject.ApplyModifiedProperties();
				dieSides.transform.rotation = dieSides.GetWorldRotationFor(0);
            }
        }

        /**
        * Show the UI that allows you to manipulate the data from the found sides or clear all data.
        */
        private void showDataSidesManipulationUI()
        {
            _sideDataDisplayed = EditorGUILayout.Foldout(
                _sideDataDisplayed, 
                //(_sideDataDisplayed ? "Hide value map" : "Show value map") + 
                "Die sides value map" + 
                " (" + _dieSides.arraySize + " sides)",
                _boldFoldout
            );

            if (_sideDataDisplayed)
            {
                DieSides dieSides = target as DieSides;
                DieSideMatchInfo dieSideMatchInfo = dieSides.GetDieSideMatchInfo();

                for (int i = 0; i < _dieSides.arraySize; i++)
                {
                    showDataSideManipulationUI(i, dieSideMatchInfo);
                }

                //this little part allows us to change the highlight while we are tabbing
                //highlight is only updated if we were already highlighting
                if (_highlightedIndex > -1)
                {
                    int currentFocus = -1;
                    string nameOfFocusedControl = GUI.GetNameOfFocusedControl() ?? "x_x";
                    bool wasParseable = int.TryParse(nameOfFocusedControl.Split('_')[0], out currentFocus);
                    if (wasParseable && _highlightedIndex != currentFocus)
                    {
                        _highlightedIndex = currentFocus;
                        dieSides.transform.rotation = dieSides.GetWorldRotationFor(_highlightedIndex);
                    }
                }

                showDataValueCountUpdateUI();

                if (GUILayout.Button("Clear sides"))
                {
                    if (EditorUtility.DisplayDialog("Warning", "This will delete all sides and their data. Are you sure?", "Yes", "No"))
                    {
                        _dieSides.arraySize = 0;
                        _valueCountPerSide.intValue = 1;
                        _showGenerationDebugData = false;
                        _generationDebugData = "";
                    }
                }

            }
        }

        /**
         * For each side, show its data manipulation UI.
         */
        private void showDataSideManipulationUI(int pSideIndex, DieSideMatchInfo pDieSideMatchInfo)
        {
            DieSides dieSides = target as DieSides;
            
            Color defaultColor = GUI.backgroundColor;

            EditorGUILayout.BeginHorizontal();

            if (_highlightedIndex == pSideIndex) GUI.backgroundColor = Color.yellow;
            string sideLabel = "Side " + pSideIndex + " = ";

            _sideLabelStyle.normal.textColor = Color.black;
            if (pDieSideMatchInfo != null && pDieSideMatchInfo.closestMatch == dieSides.GetDieSide(pSideIndex))
            {
                _sideLabelStyle.normal.textColor = pDieSideMatchInfo.isExactMatch ? darkGreen : darkBlue;
            }

            EditorGUILayout.LabelField(sideLabel, _sideLabelStyle, _sideLabelOptions);

            //show entry fields for all entries in the data array
            SerializedProperty dieSide = _dieSides.GetArrayElementAtIndex(pSideIndex);
            SerializedProperty dataArray = dieSide.FindPropertyRelative(_dieSideValuesPropertyName);

            EditorGUI.BeginChangeCheck();

            SerializedProperty element;
            for (int i = 0; i < dataArray.arraySize; i++)
            {
                element = dataArray.GetArrayElementAtIndex(i);
                //set the next controlname to sideLabel so we can focus on it
                GUI.SetNextControlName(pSideIndex+"_"+i);
                //we have to do it like this unfortunately becauses the focus mechanism doesn't
                //work well with EditorGUILayout.IntField
                //string value = GUILayout.TextField("" + element.intValue, _dataValueOptions);
                //int intValue;
                //int.TryParse(value, out intValue);
                //element.intValue = intValue;
                element.intValue = EditorGUILayout.IntField(element.intValue, _dataValueOptions);
            }

            if (EditorGUI.EndChangeCheck())
            {
                dieSides.GetDieSide(pSideIndex).DirtyStringCache();
            }

            //show a toggle button for rotating and highlight
            //and update our highlight index accordingly if pressed
            bool currentHighLight = _highlightedIndex == pSideIndex;
            bool newHighLight = GUILayout.Toggle(_highlightedIndex == pSideIndex, _rotateButtonContent, "Button", _smallEditorButtonOptions);
            if (currentHighLight != newHighLight)
            {
                _highlightedIndex = (_highlightedIndex == pSideIndex) ? -1 : pSideIndex;
                if (_highlightedIndex != -1)
                {
                    EditorGUI.FocusTextInControl(_highlightedIndex + "_0");
                    //GUI.FocusControl(_highlightedIndex + "_0");
                }
                //rotate our die so that this value/side becomes activated
                dieSides.transform.rotation = dieSides.GetWorldRotationFor(pSideIndex);
                if (!Application.isPlaying) EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
            }

            EditorGUILayout.EndHorizontal();

            GUI.backgroundColor = defaultColor;
        }

        /**
         * This UI lets you change the amount of data entries per DieSide.
         * Only required for complicated Dice (eg Descent dice)
         */
        private void showDataValueCountUpdateUI()
        {
            EditorGUILayout.BeginHorizontal(new GUILayoutOption[] { GUILayout.ExpandWidth(true) });
            EditorGUILayout.LabelField("Data values per side:", _dataCountLabelOptions);

            EditorGUILayout.LabelField(" ", _fillerLabelOptions);

            //minus button
            GUI.enabled = _valueCountPerSide.intValue > 1;
            if (GUILayout.Button("-", _smallEditorButtonOptions))
            {
                if (EditorUtility.DisplayDialog("Warning: data loss", "This will delete all data entered for column " + _valueCountPerSide.intValue, "OK", "Cancel"))
                {
                    _valueCountPerSide.intValue = Mathf.Clamp(_valueCountPerSide.intValue - 1, 1, DieSides.MAX_DATA_ENTRIES_PER_SIDE);
                    ensureDataValueCountPerSide();
                }
            }
            GUI.enabled = true;

            //amount label display
            EditorGUILayout.LabelField("" + _valueCountPerSide.intValue, _centeredText, _smallEditorButtonOptions);

            //plus button
            GUI.enabled = _valueCountPerSide.intValue < DieSides.MAX_DATA_ENTRIES_PER_SIDE;
            if (GUILayout.Button("+", _smallEditorButtonOptions))
            {
                _valueCountPerSide.intValue = Mathf.Clamp(_valueCountPerSide.intValue + 1, 1, DieSides.MAX_DATA_ENTRIES_PER_SIDE);
                ensureDataValueCountPerSide();
            }
            GUI.enabled = true;

            EditorGUILayout.EndHorizontal();
        }

        /**
         * Draws debug info about the selected die: normals & values.
         */
        void OnSceneGUI()
        {
            if (Selection.gameObjects.Length > 1 || !_debugViewOn) return;

            DieSides dieSides = target as DieSides;

            if (dieSides != null && dieSides.dieSideCount > 0)
            {
                //get the closest side match for the current orientation so we
                //can apply pretty colors
                DieSideMatchInfo dieSideMatchInfo = dieSides.GetDieSideMatchInfo();
                DieSide current = dieSideMatchInfo.closestMatch;
 
                for (int i = 0; i < dieSides.dieSideCount; i++)
                {
                    if (_highlightedIndex != -1 && _highlightedIndex != i) continue;

                    DieSide dieSide = dieSides.GetDieSide(i);
                    Vector3 worldPos = dieSides.transform.TransformPoint(dieSide.centerPoint);
                    Vector3 worldNormal = dieSides.transform.TransformDirection(dieSide.normal);
                    Vector3 endPos = worldPos + worldNormal * _labelDrawDistance;
                    Color color = Color.green;
                    Color labelColor = _labelDrawColor;

                    //should we apply our regular red/green color scheme or should we make this
                    //element blink because we selected it?
                    if (_highlightedIndex == i && Math.Floor(Time.realtimeSinceStartup * 5) % 2 == 0)
                    {
                        color = Color.yellow;
                        labelColor = Color.yellow;
                    }
                    else
                    {
                        color = dieSide == current ? Color.green : Color.red;
                    }

                    GUIStyle guiStyle = new GUIStyle();
                    guiStyle.fontSize = 20;
                    guiStyle.normal.textColor = labelColor;

					Handles.zTest = UnityEngine.Rendering.CompareFunction.LessEqual;
                    Handles.color = color;
                    Handles.DrawLine(worldPos, endPos);
                    Handles.Label(endPos, "[" + i + "]=" + dieSide.ValuesAsString(), guiStyle);
                }
            }

            SceneView.RepaintAll();
        }

		/// ///////////////////////////////////////////////////////////////////////////
		///                         HELPER METHODS
		/// ///////////////////////////////////////////////////////////////////////////                         

		private void ensureStyles()
        {
            if (!_initialized)
            {
                _initialized = true;
                _boldFoldout = new GUIStyle(EditorStyles.foldout);
                _boldFoldout.fontStyle = FontStyle.Bold;

                _centeredText = new GUIStyle(EditorStyles.label);
                _centeredText.alignment = TextAnchor.MiddleCenter;

                _centeredBox = new GUIStyle(GUI.skin.box);
                _centeredBox.alignment = TextAnchor.MiddleCenter;

                _sideLabelStyle = new GUIStyle(EditorStyles.label);
            }
        }

        /**
         * Go through all the data value arrays for each DieSide, resizing it when necessary.
         */
        private void ensureDataValueCountPerSide()
        {
            DieSides dieSides = target as DieSides;

            for (int i = 0; i < _dieSides.arraySize; i++)
            {
                SerializedProperty dieSide = _dieSides.GetArrayElementAtIndex(i);
                SerializedProperty dieSideData = dieSide.FindPropertyRelative(_dieSideValuesPropertyName);

                //if no resizing is needed, skip
                if (_valueCountPerSide.intValue == dieSideData.arraySize) continue;

                //if it is less, just set array size this will delete the superfluous values
                if (_valueCountPerSide.intValue < dieSideData.arraySize)
                {
                    dieSideData.arraySize = _valueCountPerSide.intValue;
                }
                else
                {
                    //if required number of values is bigger than what we got, 
                    //insert empty elements at the end
                    while (_valueCountPerSide.intValue > dieSideData.arraySize)
                    {
                        dieSideData.InsertArrayElementAtIndex(dieSideData.arraySize);
                        dieSideData.GetArrayElementAtIndex(dieSideData.arraySize - 1).intValue = i;
                    }
                }

                //data can be missing until serialized object is applied, so we need to check
                //whether the side is actually already there to update
                if (i < dieSides.dieSideCount) dieSides.GetDieSide(i).DirtyStringCache();
            }
        }

        private void onInspectorGUIMultiple()
        {
            EditorGUILayout.HelpBox(
                "You are in multiselect mode.\n"+
                "Select a single gameobject to return to DieSides editing mode or"+
                " drag a MaterialSet onto the tile below to re-assign all materials in your selection."
                , 
                MessageType.None
            );

            //if we add a help suddenly during the layout phase we get errors, therefore we use this 'trick'
            //to wait one frame before displaying the material info
            bool materialInfoAvailable = _materialInfo != null;
            doMaterialSetDropAreaGUI();
            materialInfoAvailable &= _materialInfo != null;

            if (materialInfoAvailable)
            {
                EditorGUILayout.HelpBox(_materialInfo, MessageType.None);
            }
        }

        private string _materialInfo = null;
        
        private void doMaterialSetDropAreaGUI()
        {
            Event evt = Event.current;
            Rect drop_area = GUILayoutUtility.GetRect(0.0f, 50.0f, GUILayout.ExpandWidth(true));
            GUI.Box(drop_area, "Drag a MaterialSet here", _centeredBox);

            switch (evt.type)
            {
                case EventType.DragUpdated:
                    if (!drop_area.Contains(evt.mousePosition)) return;
                    if (DragAndDrop.objectReferences.Length != 1) return;
                    if (!(DragAndDrop.objectReferences[0] is MaterialSet)) return;
                    DragAndDrop.visualMode = DragAndDropVisualMode.Copy;
                    DragAndDrop.AcceptDrag();
                    break;

                case EventType.DragPerform:
                    MaterialSet materialSet = DragAndDrop.objectReferences[0] as MaterialSet;
                    GameObject[] dice = targets.Select(x => (x as DieSides).gameObject).ToArray<GameObject>();
                    _materialInfo = MaterialSetUtility.MapMaterialSetToGameObjects(materialSet, dice);
                    EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
                    break;
            }
        }

		private void onInspectorGUIAlways()
		{
			if (GUILayout.Button("Place on ground"))
			{
				try
				{
					foreach (DieSides dieSides in targets)
					{
						if (dieSides.dieSideCount > 0)
						{
							dieSides.transform.rotation = dieSides.GetWorldRotationFor(0);
						}
						GroundUtility.AlignWithGround(dieSides.gameObject);
					}
				}
				catch { }
			}
		}

	} //end class

} //end namespace